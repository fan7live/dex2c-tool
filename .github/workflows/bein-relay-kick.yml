name: Encrypt APK Dex

on:
  push:
    paths:
      - input.apk
  workflow_dispatch:

jobs:
  encrypt-dex:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: 3.x

    - name: Install dependencies
      run: |
        pip install zipfile36

    - name: Encrypt classes.dex
      run: |
        python3 << 'EOF'
        import zipfile
        import os

        input_apk = "input.apk"
        output_apk = "output_encrypted.apk"
        temp_dir = "temp_apk"

        # تأكد من مسح أي مجلد مؤقت قديم
        if os.path.exists(temp_dir):
            import shutil
            shutil.rmtree(temp_dir)
        os.makedirs(temp_dir)

        # استخراج محتوى APK
        with zipfile.ZipFile(input_apk, 'r') as zip_ref:
            zip_ref.extractall(temp_dir)

        # اقرأ Package Name من AndroidManifest.xml
        import xml.etree.ElementTree as ET
        manifest_path = os.path.join(temp_dir, "AndroidManifest.xml")
        tree = ET.parse(manifest_path)
        root = tree.getroot()
        package_name = root.attrib.get("package", "defaultpkg")

        # XOR function
        def xor_encode(data, key):
            key_bytes = key.encode()
            return bytes([b ^ key_bytes[i % len(key_bytes)] for i, b in enumerate(data)])

        # تشفير كل dex
        for fname in os.listdir(temp_dir):
            if fname.startswith("classes") and fname.endswith(".dex"):
                dex_path = os.path.join(temp_dir, fname)
                with open(dex_path, "rb") as f:
                    data = f.read()
                enc_data = xor_encode(data, package_name)
                new_name = fname.replace("classes", "ijiami").replace(".dex", ".dat")
                out_path = os.path.join(temp_dir, new_name)
                with open(out_path, "wb") as f:
                    f.write(enc_data)
                os.remove(dex_path)  # احذف الملف الأصلي

        # إعادة بناء APK
        with zipfile.ZipFile(output_apk, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root_dir, dirs, files in os.walk(temp_dir):
                for file in files:
                    abs_path = os.path.join(root_dir, file)
                    rel_path = os.path.relpath(abs_path, temp_dir)
                    zipf.write(abs_path, rel_path)
        print("Encrypted APK created:", output_apk)
        EOF

    - name: Upload encrypted APK
      uses: actions/upload-artifact@v3
      with:
        name: output_encrypted.apk
        path: output_encrypted.apk
